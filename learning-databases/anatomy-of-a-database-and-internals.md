# Anatomy of a Database - It's internals

I was wondering about the anatomy of a database - basically it's internals. The term anatomy sounded nice, rooting from biology. I have heard it in many places, last I heard it was in https://youtu.be/wrESIVwc-y4 

The anatomy of a database would surely vary depending on the kind of database and the features it has! For example, some may have very few components, some may have too many probably because they have too many features as a database system

I was wondering if there are some common parts to a database given the database has some specific set of features

Say the database was NOT embedded, and was more of a client-server architecture and it could be in-memory / persistent on disk, now what all would it contain? Just a guess!

Since we say database has a client server architecture, there would be a client and a server component. If the database supports multi-server and multi-client, then multiple servers and clients ;)

I guess now this is becoming more of a - given a feature, this is a possible component in the database, hmm

If the database supports authentication with single user, then it would have a component to store this information and retrieve it in order to authenticate the user. If the database support multiple client connections concurrently and has support for only a single user in terms of authentication, then we can assume that it could support every client using the same user credentials to authenticate and is okay with that

If database has support for authentication along with multiple users, then it would have a component to store that information and retrieve it in order to authenticate the various users

Of course authentication component would have to deal with different fields of authentication data - for example, username and password. Assuming it has support for basic auth. If it has support for other forms of authentication, then the information related to that has to be stored, for example say client TLS certificates - then the database server has to store certificate(s) Certificate Authority / Authority and any client certificate signed by the Certificate Authority / any of the Certificate Authorities is said to be authenticated. This is a modern form of authentication where clients / users use TLS certificates. The communication between the client and server can also be encrypted with such certificates. I'm not sure if servers do such a thing as of now, they might be doing it, it makes sense in some cases, but it's something to checkout. Or the standard TLS certificate and HTTPS for communication can be used too if HTTP is the protocol used for communication between the client and server

We spoke about authentication, there's also authorization! But before we go to authorization, it has to be clear as to what kind of operations / actions can be performed in the database and then think about naming those actions and then one can define roles to mention which role can perform what operations / actions and then assign role(s) to users. If a user belongs to a role and the role has some set of permissions to do some operations, then the user has permission to do those operation. user -> role(s) , role -> permission(s) to do operation(s) => user -> permission(s) to do operation(s). Now, I want to call out that this is popularly called as Role Based Access Control (RBAC), just one of the forms of access control when it comes to authorization in order to define some sort "access" or "levels of access" and what level of access each user has. There are other forms of authorization, which I don't know anything about but they could be used too! Depending on what makes sense for the users of the database and for the creators! And what the goal of the component is - for example, one goal could be - ease of understanding authorization, then creators could just choose a popular authorization mechanism like RBAC or something too simple too - say "read" and "write" access, and that's it! ;) Not to mention, RBAC is kind of popular, and I have seen it used in GitLab, Kubernetes, GitHub. Some of them have pre-defined roles, some of them allow you to define your own custom roles with granular permissions, for example in Kubernetes you can do that, but one must beware that it can lead to creating too many roles, if you want to go too granular, one could say - one role for one permission, then you have as many roles as the permissions, lol! Too hard to provide access to users by adding each and every role to the user to give them proper and enough access. So, it's better to group permissions in some sensible way. For example, a popular thing I have seen is - if a user has access to write, then they have access to read too. That's like a sensible thing, because what's the point in having write access if I can't read? Then it becomes impossible to update based on old content by checking what's in there, or if patching is an option apart from overriding, just assume that it will work and patch it and not be able to read it before or after the patch, to know if the patch worked at all. That's just too crazy. So, yeah, sensible access!

So, now we know some possible features and components of a database, which seem too obvious now that I think about it! Assuming some things, some features and components are -

- Client
- Server
- Authentication and Authorization

And since it's client server, there has to be some sort of protocol for the communication and some component to take care of understanding that protocol. Usually this is all ecompassed in the client and server. For example, a database could use HTTP protocol with JSON data. It has it's advantages and disadvantages too. For example, JSON could be too big - but it's human readable. An alternative for JSON is Protocol Buffers (Protobuf), and there might be more alternatives, I just know this one. Protocol Buffers tries to use less bytes to encode more information, which can be useful so that we can use less network bandwidth and possibly send data faster between the client and server. I have commonly seen TCP based custom protocols - for example, Redis uses RESP - Redis Serialization Protocol and uses a very light weight protocol with some readability. For example, it uses a single first byte to denote the kind of message that is being sent - error, string, integer etc - https://redis.io/topics/protocol#resp-protocol-description . And it uses a custom protocol on top of TCP. HTTP for example is a standard protocol on top of TCP. An alternative for Redis's first byte can be to use multiple bytes to say "ERROR", "SIMPLE STRING" etc but that would cost Redis a lot of bytes which is obvious so they just encode all this information in the client and server program and just use a single byte to denote the kind of message. Not to mention, there are alternatives to TCP that's coming up - one example is QUIC - https://en.wikipedia.org/wiki/QUIC 

